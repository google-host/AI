BFS-DFS
#include<iostream>
#include<stack>
#include<queue>
using namespace std;
class Node {
public:
 int data;
 Node *left, *right;
 Node(int val) : data(val), left(nullptr), right(nullptr) {}
};
class Tree {
 Node* insert(Node* root, int val) {
 if (!root) return new Node(val);
 if (val < root->data) root->left = insert(root->left, val);
 else if (val > root->data) root->right = insert(root->right, val);
 return root;
 }
public:
 Node* root = nullptr;
 void create(int val) {
 root = insert(root, val);
 }
 void dfsPreorder(Node* root) {
 if (!root) return;
 stack<Node*> s;
 s.push(root);
 while (!s.empty()) {
 Node* curr = s.top(); s.pop();
 cout << curr->data << " ";
 if (curr->right) s.push(curr->right);
 if (curr->left) s.push(curr->left);
 }
 cout << endl;
 }
 void dfsInorder(Node* root) {
 stack<Node*> s;
 Node* curr = root;
 while (curr || !s.empty()) {
 while (curr) { s.push(curr); curr = curr->left; }
 curr = s.top(); s.pop();
 cout << curr->data << " ";
 curr = curr->right;
 }
 cout << endl;
 }
 void dfsPostorder(Node* root) {
 if (!root) return;
 stack<Node*> s1, s2;
 s1.push(root);
 while (!s1.empty()) {
 Node* curr = s1.top(); s1.pop();
 s2.push(curr);
 if (curr->left) s1.push(curr->left);
 if (curr->right) s1.push(curr->right);
 }
 while (!s2.empty()) {
 cout << s2.top()->data << " "; s2.pop();
 }
 cout << endl;
 }
 void bfs(Node* root) {
 if (!root) return;
 queue<Node*> q;
 q.push(root);
 while (!q.empty()) {
 Node* curr = q.front(); q.pop();
 cout << curr->data << " ";
 if (curr->left) q.push(curr->left);
 if (curr->right) q.push(curr->right);
 }
 cout << endl;
 }
};
int main() {
 Tree t;
 int choice, order, val;
 cout << "1. DFS\n2. BFS\nEnter choice: ";
 cin >> choice;
 cout << "Enter 6 values:\n";
 for (int i = 0; i < 6; ++i) {
 cin >> val;
 t.create(val);
 }
 if (choice == 1) {
 cout << "1. Preorder\n2. Inorder\n3. Postorder\nEnter DFS order: ";
 cin >> order;
 if (order == 1) t.dfsPreorder(t.root);
 else if (order == 2) t.dfsInorder(t.root);
 else if (order == 3) t.dfsPostorder(t.root);
 else cout << "Invalid DFS choice.\n";
 } else if (choice == 2) {
 t.bfs(t.root);
 } else {
 cout << "Invalid choice.\n";
 }
 return 0;
}
